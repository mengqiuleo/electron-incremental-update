import type { Buffer } from 'node:buffer'
import type { UpdateJSON } from '../updateJson'
import type { MinimumVersionError, VerifyFailedError } from '.'

export type CheckResultType = {
  size: number
  version: string
} | undefined | Error | MinimumVersionError | TypeError
export type DownloadResult = true | Error | VerifyFailedError | TypeError
type UpdateEvents = {
  downloading: [progress: number]
  downloadBuffer: [buffer: Buffer]
  debug: [msg: string | Error]
}

type Evt = Exclude<keyof UpdateEvents, number>
export interface Updater {
  removeAllListeners<E extends Evt>(event?: E): this
  listeners<E extends Evt>(eventName: E): Function[]
  eventNames(): Evt[]
  on<E extends Evt>(eventName: E, listener: (...data: UpdateEvents[E]) => void): this
  once<E extends Evt>(eventName: E, listener: (...data: UpdateEvents[E]) => void): this
  emit<E extends Evt>(eventName: E, ...args: UpdateEvents[E]): boolean
  off<E extends Evt>(eventName: E, listener: (...args: UpdateEvents[E]) => void): this
  /**
   * check update info
   * @param data update json url
   * @returns
   * - `{size: number, version: string}`: available
   * - `false`: unavailable
   * - `Error`: fail ({@link MinimumVersionError} or other)
   */
  checkUpdate(data?: string | UpdateJSON): Promise<CheckResultType>
  /**
   * download update
   *
   * if you want to update **offline**, you can set both `src` and `sig` to verify and install
   * @param data asar download url or buffer
   * @param sig signature
   * @returns
   * - `true`: success
   * - `Error`: fail ({@link VerifyFailedError} or other)
   */
  download(data?: string | Buffer, sig?: string): Promise<DownloadResult>
  debug: boolean
  productName: string
  receiveBeta: boolean
}
export type FunctionVerifySignature = (
  buffer: Buffer, signature: string, cert: string
) => string | false | Promise<string | false>
export type FunctionCompareVersion = (oldVersion: string, newVersion: string) => boolean | Promise<boolean>
export type FunctionDownloadBuffer = (url: string, updater: Updater, headers: Record<string, any>) => Promise<Buffer>
export type FunctionDownloadJSON = (url: string, updater: Updater, headers: Record<string, any>) => Promise<UpdateJSON>

export type UpdaterOverrideFunctions = {
  /**
   * custom version compare function {@link FunctionCompareVersion}
   * @param oldVersion old version string
   * @param newVersion new version string
   * @returns whether oldVersion < newVersion
   */
  compareVersion?: FunctionCompareVersion
  /**
   * custom verify signature function {@link FunctionVerifySignature}
   * @param buffer file buffer
   * @param signature signature
   * @param cert certificate
   */
  verifySignaure?: FunctionVerifySignature
  /**
   * custom download JSON function
   * @param url download url
   * @param updater updater, to trigger events
   * @param header download header
   * @returns `UpdateJSON`
   */
  downloadJSON?: FunctionDownloadJSON
  /**
   * custom download buffer function
   * @param url download url
   * @param updater updater, to trigger events
   * @param header download header
   * @returns `Buffer`
   */
  downloadBuffer?: FunctionDownloadBuffer
}

export type UpdaterDownloadConfig = {
  /**
   * download user agent
   * @default 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36'
   */
  userAgent?: string
  /**
   * extra download header, `accept` and `user-agent` is set by default
   */
  extraHeader?: Record<string, string>
}

export interface UpdaterOption {
  /**
   * public key of signature, which will be auto generated by plugin
   * @example
   * ```ts
   * // auto filled by plugin
   * const SIGNATURE_CERT = ''
   *
   * const updater = createUpdater({
   *   SIGNATURE_CERT,
   *   ...
   * })
   * ```
   */
  SIGNATURE_CERT: string
  /**
   * name of your application
   *
   * you can use the `name` in `package.json`
   */
  productName: string
  /**
   * repository url, e.g. `https://github.com/electron/electron`
   *
   * you can use the `repository` in `package.json`
   *
   * if `updateJsonURL` or `releaseAsarURL` are absent,
   * `repository` will be used to determine the url
   */
  repository?: string
  /**
   * URL of version info json
   * @default `${repository.replace('github.com', 'raw.githubusercontent.com')}/master/version.json`
   * @throws if `updateJsonURL` and `repository` are all not set
   */
  updateJsonURL?: string
  /**
   * URL of release asar.gz
   * @default `${repository}/releases/download/v${version}/${productName}-${version}.asar.gz`
   * @throws if `releaseAsarURL` and `repository` are all not set
   */
  releaseAsarURL?: string
  /**
   * whether to enable debug listener
   */
  debug?: boolean
  /**
   * whether to receive beta update
   */
  receiveBeta?: boolean
  overrideFunctions?: UpdaterOverrideFunctions
  downloadConfig?: UpdaterDownloadConfig
}
